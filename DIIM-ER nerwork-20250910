import numpy as np  
import networkx as nx  
import matplotlib.pyplot as plt  

# 生成Erdős-Rényi网络  
N = 100  
G = nx.erdos_renyi_graph(N, 0.1)  
A = nx.adjacency_matrix(G).toarray()  

# 初始化参数  
T = 50  # 时间步数  
k_rec = 0.3  # 恢复率系数  
q_states = [0.0, 0.3, 0.6, 0.9, 1.0]  # 不可操作性区间  

# 多状态互依赖矩阵定义  
def update_A_matrix(q, states):  
    A_dyn = np.zeros((N, N))  
    for i in range(N):  
        q_i = q[i]  
        # 确定q_i所在区间（文档1的r_e^i）  
        interval_idx = np.digitize(q_i, states) - 1  
        interval_idx = min(max(interval_idx, 0), len(states)-2)  
        # 简化的互依赖系数：区间越高，影响越大  
        for j in range(N):  
            if A[i, j] > 0:  
                A_dyn[i, j] = 0.1 * (interval_idx + 1)  # a_ij随状态区间增加  
    return A_dyn  

# DIIM动态方程（文档1公式4）  
def diim_dynamics(q0, A_dyn, K, t_steps):  
    q = np.zeros((t_steps, N))  
    q[0] = q0  
    K_mat = np.diag([k_rec] * N)  # 恢复矩阵（对角阵）  
    for t in range(1, t_steps):  
        q_prev = q[t-1]  
        # 更新互依赖矩阵（文档1多状态扩展）  
        A_t = update_A_matrix(q_prev, q_states)  
        # 动态方程: q(t+1) = q(t) - K q(t) + K A_t q(t)  
        q[t] = q_prev - K_mat @ q_prev + K_mat @ A_t @ q_prev  
    return q  

# 设置初始扰动  
q0 = np.zeros(N)  
perturb_node = np.random.randint(0, N)  
q0[perturb_node] = 0.8  # 初始节点失效  

# 模拟动态  
q_history = diim_dynamics(q0, A, np.array([k_rec]*N), T)  

# 可视化结果  
plt.figure(figsize=(10, 6))  
for i in range(N):  
    plt.plot(q_history[:, i], alpha=0.1, color='blue')  
plt.plot(q_history[:, perturb_node], 'r-', linewidth=2, label='Perturbed Node')  
plt.title("Document 1: Multi-state DIIM Dynamics")  
plt.xlabel("Time Step")  
plt.ylabel("Inoperability (q_i)")  
plt.legend()  
plt.show()
